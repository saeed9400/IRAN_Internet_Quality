<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title data-lang-key="title">ابزار بررسی کیفیت اینترنت – نسخه دوم وب</title>
  <link rel="icon" href="https://raw.githubusercontent.com/saeed9400/IRAN_Internet_Quality/refs/heads/main/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@33.003/Vazirmatn-font-face.css">
  <style>
    :root {
      --bg: #0a0a0f;
      --card: #181c2e;
      --text: #e0e7ff;
      --muted: #a0a8c0;
      --accent: #6366f1;
      --success: #22c55e;
      --warning: #eab308;
      --danger: #ef4444;
      --border: #2a2f4f;
      --radius: 10px;
    }
    body {
      font-family: 'Vazirmatn', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 1.5rem;
      line-height: 1.6;
    }
    header, footer {
      background: #15193a;
      padding: 1.2rem;
      text-align: center;
    }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 1.3rem;
      margin-bottom: 1.5rem;
      border: 1px solid var(--border);
    }
    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.05rem;
    }
    button:hover { background: #818cf8; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .timer {
      display: inline-block;
      margin-right: 1rem;
      padding: 0.5rem 1rem;
      background: #1e2338;
      border-radius: 20px;
      font-family: monospace;
      font-size: 1.1rem;
    }
    select {
      padding: 0.65rem;
      border-radius: 8px;
      background: #11151f;
      color: var(--text);
      border: 1px solid var(--border);
    }
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0 0.5rem;
      font-size: 0.92rem;
    }
    th, td {
      padding: 0.9rem 1rem;
      text-align: right;
    }
    th {
      background: #11151f;
      color: var(--muted);
      border-bottom: 2px solid var(--border);
    }
    tr {
      background: #181c2e;
      border-radius: var(--radius);
    }
    .ok { color: var(--success); font-weight: bold; }
    .fail { color: var(--danger); }
    .warn { color: var(--warning); }
    .info { color: var(--muted); font-style: italic; }
    .code { font-family: monospace; direction: ltr; word-break: break-all; font-size: 0.85rem; background: #0d1117; padding: 0.3rem 0.6rem; border-radius: 6px; }
    .manual-links {
      margin: 1rem 0;
      padding: 1rem;
      background: #11151f;
      border-radius: var(--radius);
      display: none;
    }
    .manual-links a {
      display: inline-block;
      background: var(--success);
      color: white;
      padding: 0.7rem 1.4rem;
      margin: 0.4rem;
      border-radius: 8px;
      text-decoration: none;
    }
    .manual-links a:hover { background: #16a34a; }
    .summary {
      margin-top: 1.5rem;
      padding: 1.2rem;
      background: #1e2338;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      font-size: 1.05rem;
      line-height: 1.7;
      display: none;
    }
    .summary h3 {
      margin-top: 0;
      color: var(--success);
    }
    footer {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-top: 2rem;
      text-align: center;
    }
    .github-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: #60a5fa;
      text-decoration: none;
      font-size: 0.95rem;
    }
    .github-link svg { fill: currentColor; width: 20px; height: 20px; }
    .github-link:hover { color: #93c5fd; }
    a.external-link {
      color: #60a5fa;
      text-decoration: underline;
    }
    a.external-link:hover { color: #93c5fd; }
  </style>
</head>
<body>
<header>
  <h1 data-lang-key="title">ابزار بررسی کیفیت اینترنت – نسخه دوم وب</h1>
</header>
<main>
  <div class="card">
    <p data-lang-key="desc">
      در این ابزار <b>دانلود واقعی فایل</b> انجام می‌شود.<br>
      بعد از اتمام تست، نتیجه نهایی کیفیت اینترنت شما نمایش داده می‌شود.
    </p>
    <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
      <div>
        <label data-lang-key="lang_label">زبان / Language:</label>
        <select id="lang">
          <option value="fa" selected>فارسی</option>
          <option value="en">English</option>
        </select>
      </div>
      <button id="start" data-lang-key="start">شروع تست</button>
      <span id="timer" class="timer" style="display: none;">⏱️ 0:00</span>
    </div>
  </div>

  <div class="card">
    <table>
      <thead>
        <tr>
          <th data-lang-key="th_test">تست</th>
          <th data-lang-key="th_status">وضعیت</th>
          <th data-lang-key="th_result">نتیجه</th>
          <th data-lang-key="th_time">زمان</th>
          <th data-lang-key="th_size">حجم</th>
          <th data-lang-key="th_source">منبع / روش</th>
        </tr>
      </thead>
      <tbody id="out"></tbody>
    </table>
  </div>

  <div class="manual-links" id="manual"></div>

  <div class="summary" id="summary">
    <h3 data-lang-key="summary_title">نتیجه نهایی کیفیت اینترنت شما</h3>
    <div id="summaryContent"></div>
  </div>
</main>

<footer>
  <p data-lang-key="footer_cors">
    دانلودهایی که به دلیل CORS بلاک می‌شوند، به‌عنوان «مسدود توسط مرورگر» گزارش می‌شوند.
  </p>
  <p data-lang-key="footer_success">
    اگر دانلود واقعی انجام شد → مسیر دانلود شما باز است.
  </p>
  <a href="https://github.com/saeed9400/" target="_blank" class="github-link">
    <span data-lang-key="github">پروژه در GitHub</span>
    <svg viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
  </a>
</footer>

<script>
// ترجمه‌های کامل دو زبانه
const TXT = {
  fa: {
    title: "ابزار بررسی کیفیت اینترنت – نسخه دوم وب",
    desc: "در این ابزار <b>دانلود واقعی فایل</b> انجام می‌شود.<br>بعد از اتمام تست، نتیجه نهایی کیفیت اینترنت شما نمایش داده می‌شود.",
    lang_label: "زبان / Language:",
    start: "شروع تست",
    th_test: "تست",
    th_status: "وضعیت",
    th_result: "نتیجه",
    th_time: "زمان",
    th_size: "حجم",
    th_source: "منبع / روش",
    ok: "موفق",
    fail: "ناموفق",
    warn: "هشدار",
    info: "اطلاعات بیشتر",
    
    // پیام‌های دانلود
    download_success: "دانلود واقعی انجام شد",
    download_fail: "مسدود توسط مرورگر (CORS) – لطفاً روی لینک دستی کلیک کنید",
    download_unavailable: "تست مستقیم امکان‌پذیر نیست - لینک دستی",
    server_available: "سرور در دسترس (HEAD)",
    
    // آی‌پی
    no_ip: "عدم دریافت IP",
    ip_shown: "IP مشاهده‌شده: ",
    ipv4: "مسیر IPv4",
    ipv6: "مسیر IPv6",
    ipv4_fallback: "IPv4 جایگزین",
    ipv6_yes: "IPv6 فعال است",
    ipv6_no: "IPv6 غیرفعال است",
    
    // فوتر
    footer_cors: "دانلودهایی که به دلیل CORS بلاک می‌شوند، به‌عنوان «مسدود توسط مرورگر» گزارش می‌شوند.",
    footer_success: "اگر دانلود واقعی انجام شد → مسیر دانلود شما باز است.",
    github: "پروژه در GitHub",
    
    // لینک‌های دستی
    manual_title: "لینک‌های دانلود دستی (برای تست‌هایی که مستقیم امکان‌پذیر نیست)",
    manual_note: "روی لینک کلیک کنید و دانلود را دستی انجام دهید تا وضعیت سرور مشخص شود.",
    
    // خلاصه نهایی
    summary_title: "نتیجه نهایی کیفیت اینترنت شما",
    summary_good: "کیفیت اینترنت شما <strong>خوب</strong> است.<br>مسیرهای اصلی تست‌شده باز هستند.",
    summary_medium: "کیفیت اینترنت شما <strong>متوسط</strong> است.<br>بعضی مسیرها باز هستند، اما محدودیت‌هایی وجود دارد.",
    summary_bad: "کیفیت اینترنت شما <strong>پایین یا محدود</strong> است.<br>بیشتر مسیرها بلاک شدند.",
    summary_ip: "IP شما: <a href='https://whatismyipaddress.com/ip/[IP]' target='_blank' class='external-link'>[IP]</a>",
    summary_success_count: "دانلودهای موفق: [COUNT] از [TOTAL] (تست‌های واقعی)",
    summary_ipv6_note: " IPv6 واقعی شناسایی نشد - اتصال شما از طریق IPv4 است",
    summary_ipv6_success: " IPv6 واقعی فعال است",
    summary_cors_note: " برخی تست‌ها به دلیل محدودیت CORS ناموفق بودند - لینک‌های دستی را چک کنید",
    summary_manual: "برای اطمینان، لینک‌های دستی را تست کنید.",
    summary_timeout_note: " برخی سرورها زمان پاسخ‌دهی طولانی دارند یا مسدود هستند",
    
    // تست‌های اختصاصی
    dns_hijack_test: "تست ربودن DNS",
    dns_hijack_yes: "ربودن DNS تشخیص داده شد",
    dns_hijack_no: "بدون ربودن DNS",
    dns_error: "خطا در دریافت پاسخ DNS",
    dns_timeout: "DNS Server Timeout - احتمال فیلتر یا اختلال",
    
    quality_test: "نتیجه بررسی کیفیت (پینگ)",
    quality_good: "کیفیت خوب",
    quality_average: "کیفیت متوسط",
    quality_poor: "کیفیت ضعیف",
    quality_failed: "تست ناموفق",
    ping: "پینگ متوسط",
    jitter: "جیتر",
    
    quic_test: "تست QUIC",
    quic_supported: "QUIC پشتیبانی می‌شود",
    quic_unsupported: "QUIC پشتیبانی نمی‌شود",
    quic_cors_blocked: "QUIC - مسدود توسط مرورگر (CORS)",
    
    doh_test: "تست DoH",
    doh_supported: "DoH پشتیبانی می‌شود",
    doh_unsupported: "DoH پشتیبانی نمی‌شود",
    doh_timeout: "DoH Server Timeout",
    
    webrtc_test: "تست WebRTC",
    webrtc_supported: "WebRTC پشتیبانی می‌شود",
    webrtc_unsupported: "WebRTC پشتیبانی نمی‌شود",
    
    connectivity_test: "تست اتصال عمومی / CDN / IP",
    connectivity_good: "اتصال عمومی خوب",
    connectivity_medium: "اتصال متوسط / برخی مشکلات",
    connectivity_bad: "مشکل جدی در اتصال عمومی",
    
    // برچسب‌های منابع
    ping_google: "پینگ گوگل",
    ping_cloudflare: "پینگ کلادفلر",
    ping_wikipedia: "پینگ ویکی‌پدیا",
    ping_github: "پینگ گیت‌هاب",
    ping_openwrt: "پینگ OpenWRT",
    cf_trace: "ردیابی کلادفلر",
    ipify_ipv4: "آی‌پی IPv4",
    httpbin_get: "HTTPBin GET",
    cf_speed_100kb: "تست دانلود ۱۰۰کیلوبایت کلادفلر",
    cf_speed_1mb: "تست دانلود ۱مگابایت کلادفلر",
    jsdelivr: "jsDelivr lodash",
    openwrt_lastupdate: "OpenWRT آخرین بروزرسانی",
    unpkg_react: "unpkg react (اطلاعاتی)",
    ovh_test: "OVH فایل تست",
    github_passwall: "Passwall2 IPK (گیت‌هاب)",
    sourceforge_passwall: "Passwall Packages (سورس‌فورج)"
  },
  en: {
    title: "Internet Quality Tester – Web 2nd Version",
    desc: "This tool performs <b>real file download</b>.<br>After the test, a final summary of your internet quality will be shown.",
    lang_label: "Language:",
    start: "Start Test",
    th_test: "Test",
    th_status: "Status",
    th_result: "Result",
    th_time: "Time",
    th_size: "Size",
    th_source: "Source / Method",
    ok: "OK",
    fail: "Fail",
    warn: "Warning",
    info: "Info",
    
    download_success: "Real download completed",
    download_fail: "Blocked by browser (CORS) – click manual link",
    download_unavailable: "Direct test unavailable - manual link",
    server_available: "Server reachable (HEAD)",
    
    no_ip: "Failed to get IP",
    ip_shown: "Visible IP: ",
    ipv4: "IPv4 Route",
    ipv6: "IPv6 Route",
    ipv4_fallback: "IPv4 Fallback",
    ipv6_yes: "IPv6 enabled",
    ipv6_no: "IPv6 disabled",
    
    footer_cors: "Downloads blocked by CORS are reported as «Blocked by browser».",
    footer_success: "If real download succeeded → your download path is open.",
    github: "Project on GitHub",
    
    manual_title: "Manual Download Links (for tests that cannot be done directly)",
    manual_note: "Click the link and download manually to check server accessibility.",
    
    summary_title: "Final Internet Quality Summary",
    summary_good: "Your internet quality is <strong>good</strong>.<br>Main tested paths are open.",
    summary_medium: "Your internet quality is <strong>medium</strong>.<br>Some paths work, but there are restrictions.",
    summary_bad: "Your internet quality is <strong>low or restricted</strong>.<br>Most paths are blocked.",
    summary_ip: "Your IP: <a href='https://whatismyipaddress.com/ip/[IP]' target='_blank' class='external-link'>[IP]</a>",
    summary_success_count: "Successful downloads: [COUNT] of [TOTAL] (real tests)",
    summary_ipv6_note: " No native IPv6 detected - your connection uses IPv4",
    summary_ipv6_success: " Native IPv6 is active",
    summary_cors_note: " Some tests failed due to CORS - check manual links",
    summary_manual: "For certainty, test the manual links.",
    summary_timeout_note: " Some servers are timing out or blocked",
    
    dns_hijack_test: "DNS Hijack Test",
    dns_hijack_yes: "DNS Hijack detected",
    dns_hijack_no: "No DNS Hijack",
    dns_error: "Error getting DNS response",
    dns_timeout: "DNS Server Timeout - Possible filtering",
    
    quality_test: "Quality Test (Ping)",
    quality_good: "Good quality",
    quality_average: "Average quality",
    quality_poor: "Poor quality",
    quality_failed: "Test failed",
    ping: "Average ping",
    jitter: "Jitter",
    
    quic_test: "QUIC Test",
    quic_supported: "QUIC supported",
    quic_unsupported: "QUIC unsupported",
    quic_cors_blocked: "QUIC - Blocked by CORS",
    
    doh_test: "DoH Test",
    doh_supported: "DoH supported",
    doh_unsupported: "DoH unsupported",
    doh_timeout: "DoH Server Timeout",
    
    webrtc_test: "WebRTC Test",
    webrtc_supported: "WebRTC supported",
    webrtc_unsupported: "WebRTC unsupported",
    
    connectivity_test: "General / CDN / IP Connectivity Test",
    connectivity_good: "Good general connectivity",
    connectivity_medium: "Medium connectivity / some issues",
    connectivity_bad: "Serious connectivity issues",
    
    ping_google: "Google ping",
    ping_cloudflare: "Cloudflare ping",
    ping_wikipedia: "Wikipedia ping",
    ping_github: "GitHub ping",
    ping_openwrt: "OpenWRT ping",
    cf_trace: "Cloudflare Trace",
    ipify_ipv4: "IPv4 Address",
    httpbin_get: "HTTPBin GET",
    cf_speed_100kb: "Cloudflare 100KB download test",
    cf_speed_1mb: "Cloudflare 1MB download test",
    jsdelivr: "jsDelivr lodash",
    openwrt_lastupdate: "OpenWRT lastupdate",
    unpkg_react: "unpkg react (info)",
    ovh_test: "OVH test file",
    github_passwall: "Passwall2 IPK (GitHub)",
    sourceforge_passwall: "Passwall Packages (SourceForge)"
  }
};

let LANG = "fa";
let running = false;
let successCount = 0;
let totalRealTests = 0;
let ipDetected = "";
let ipv6Real = false;
let abortController = null;
let timerInterval = null;
let secondsElapsed = 0;

const langSelect = document.getElementById("lang");
const startBtn = document.getElementById("start");
const timerEl = document.getElementById("timer");
const out = document.getElementById("out");
const manual = document.getElementById("manual");
const summary = document.getElementById("summary");
const summaryContent = document.getElementById("summaryContent");

// منابع تست کیفیت (پینگ)
const QUALITY_SOURCES = [
  { nameKey: "ping_google", url: "https://www.google.com/generate_204" },
  { nameKey: "ping_cloudflare", url: "https://www.cloudflare.com/cdn-cgi/trace" },
  { nameKey: "ping_wikipedia", url: "https://en.wikipedia.org/api/rest_v1/page/random/title" },
  { nameKey: "ping_github", url: "https://api.github.com" },
  { nameKey: "ping_openwrt", url: "https://downloads.openwrt.org/releases/lastupdate" }
];

// منابع تست اتصال عمومی
const CONNECTIVITY_SOURCES = [
  { nameKey: "cf_trace", url: "https://www.cloudflare.com/cdn-cgi/trace", check: text => text.includes("colo=") || text.includes("fl=") },
  { nameKey: "ipify_ipv4", url: "https://api.ipify.org", check: text => text.trim().match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) },
  { nameKey: "httpbin_get", url: "https://httpbin.org/get", check: json => json && json.origin },
  { nameKey: "cf_speed_100kb", url: "https://speed.cloudflare.com/__down?bytes=100000", check: () => true }
];

// منابع دانلود
const DOWNLOAD_SOURCES = [
  { labelKey: "jsdelivr", url: "https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js", maxBytes: 512*1024, isReal: true },
  { labelKey: "openwrt_lastupdate", url: "https://downloads.openwrt.org/releases/lastupdate", maxBytes: 128*1024, isReal: true },
  { labelKey: "unpkg_react", url: "https://unpkg.com/react@18/umd/react.production.min.js", maxBytes: 512*1024, isReal: false },
  { labelKey: "cf_speed_1mb", url: "https://speed.cloudflare.com/__down?bytes=1000000", maxBytes: 1024*1024, isReal: true }
];

function updateLanguage() {
  document.documentElement.lang = LANG;
  document.documentElement.dir = LANG === "fa" ? "rtl" : "ltr";
  document.querySelectorAll("[data-lang-key]").forEach(el => {
    const k = el.getAttribute("data-lang-key");
    if (TXT[LANG][k]) el.innerHTML = TXT[LANG][k];
  });
  if (!running) startBtn.textContent = TXT[LANG].start;
}

langSelect.onchange = e => {
  LANG = e.target.value;
  updateLanguage();
  resetUI();
};

updateLanguage();

function resetUI() {
  out.innerHTML = "";
  manual.innerHTML = `<h3>${TXT[LANG].manual_title}</h3><p>${TXT[LANG].manual_note}</p>`;
  manual.style.display = "none";
  summary.style.display = "none";
  summaryContent.innerHTML = "";
}

function startTimer() {
  secondsElapsed = 0;
  timerEl.style.display = "inline-block";
  timerEl.textContent = `⏱️ 0:00`;
  timerInterval = setInterval(() => {
    secondsElapsed++;
    const mins = Math.floor(secondsElapsed / 60);
    const secs = secondsElapsed % 60;
    timerEl.textContent = `⏱️ ${mins}:${secs.toString().padStart(2, '0')}`;
  }, 1000);
}

function stopTimer() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
  timerEl.style.display = "none";
}

function row(test, status, result, time = "—", size = "—", source = "", statusClass = null) {
  const tr = document.createElement("tr");
  const finalStatusClass = statusClass || (status === "ok" ? "ok" : status === "fail" ? "fail" : status === "info" ? "info" : "warn");
  const statusText = TXT[LANG][status] || status;
  tr.innerHTML = `<td>${test}</td><td class="${finalStatusClass}">${statusText}</td><td>${result}</td><td>${time}</td><td>${size}</td><td class="code">${source}</td>`;
  out.appendChild(tr);
}

async function timed(fn, timeout = 8000) {
  const start = performance.now();
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const val = await fn(controller.signal);
    clearTimeout(timeoutId);
    return { ok: true, val, ms: Math.round(performance.now() - start) };
  } catch (err) {
    clearTimeout(timeoutId);
    let errorMsg = err.message;
    if (err.name === 'AbortError') {
      errorMsg = 'Timeout';
    }
    return { ok: false, err: errorMsg, ms: Math.round(performance.now() - start) };
  }
}

function addManualLink(label, url) {
  const linkContainer = document.createElement("div");
  const link = document.createElement("a");
  link.href = url;
  link.target = "_blank";
  link.rel = "noopener noreferrer";
  link.textContent = label;
  linkContainer.appendChild(link);
  manual.appendChild(linkContainer);
  manual.style.display = "block";
}

async function ipTest(labelKey, url, expectV6) {
  const t = await timed(async (signal) => {
    const res = await fetch(url, { signal, cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return (await res.text()).trim();
  });

  if (t.ok) {
    const ip = t.val;
    const isV6 = ip.includes(":");
    
    if (expectV6) {
      ipv6Real = isV6;
      const status = isV6 ? "ok" : "info";
      const result = isV6 ? TXT[LANG].ipv6_yes : `${TXT[LANG].ipv4_fallback}: ${ip}`;
      const statusClass = isV6 ? "ok" : "info";
      row(TXT[LANG][labelKey], status, result, `${t.ms} ms`, "—", url, statusClass);
    } else {
      ipDetected = ip;
      row(TXT[LANG][labelKey], "ok", TXT[LANG].ip_shown + ip, `${t.ms} ms`, "—", url);
    }
  } else {
    row(TXT[LANG][labelKey], "fail", TXT[LANG].no_ip + (t.err ? ` (${t.err})` : ''), `${t.ms} ms`, "—", url);
  }
}

async function testConnectivity() {
  let success = 0;
  let totalTime = 0;

  for (const src of CONNECTIVITY_SOURCES) {
    if (!running) break;
    const t = await timed(async (signal) => {
      const res = await fetch(src.url, { signal, cache: "no-store", mode: "cors" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const contentType = res.headers.get("content-type");
      const content = contentType?.includes("json") ? await res.json() : await res.text();
      if (src.check && !src.check(content)) throw new Error("Invalid content");
      return true;
    });

    const rowStatus = t.ok ? "ok" : "fail";
    const rowResult = t.ok ? `OK (${t.ms} ms)` : `Failed (${t.ms} ms - ${t.err || 'error'})`;
    row(`↳ ${TXT[LANG][src.nameKey]}`, rowStatus, rowResult, `${t.ms} ms`, "—", src.url);

    if (t.ok) {
      success++;
      totalTime += t.ms;
    }
  }

  const finalStatus = success >= CONNECTIVITY_SOURCES.length ? "ok" : success >= CONNECTIVITY_SOURCES.length / 2 ? "warn" : "fail";
  const avg = success > 0 ? Math.round(totalTime / success) : "—";

  row(TXT[LANG].connectivity_test, finalStatus, 
    finalStatus === "ok" ? TXT[LANG].connectivity_good :
    finalStatus === "warn" ? TXT[LANG].connectivity_medium :
    TXT[LANG].connectivity_bad,
    "—", "—", `Success: ${success}/${CONNECTIVITY_SOURCES.length} • Avg: ${avg} ms`);

  if (success >= CONNECTIVITY_SOURCES.length / 2) successCount++;
}

async function testDNSHijack() {
  const urls = [
    "https://dns.google/resolve?name=telegram.org&type=A",
    "https://cloudflare-dns.com/dns-query?name=telegram.org&type=A"
  ];
  
  let success = false;
  let resultText = TXT[LANG].dns_hijack_no;
  let statusClass = "ok";
  let timeMs = 0;
  let lastError = '';

  for (const url of urls) {
    const t = await timed(async (signal) => {
      const res = await fetch(url, { 
        signal, 
        cache: "no-store", 
        mode: "cors",
        headers: { 'Accept': 'application/dns-json' }
      }, 5000);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    }, 5000);

    timeMs = t.ms;
    lastError = t.err || '';
    
    if (t.ok && t.val.Answer) {
      success = true;
      for (const ans of t.val.Answer) {
        const ip = ans.data;
        if (ip && (ip.startsWith("10.") || ip.startsWith("192.168.") || ip.startsWith("172.") || ip.startsWith("37.228."))) {
          resultText = TXT[LANG].dns_hijack_yes + ` (${ip})`;
          statusClass = "warn";
          break;
        }
      }
      break;
    }
  }

  if (!success) {
    resultText = lastError === 'Timeout' ? TXT[LANG].dns_timeout : TXT[LANG].dns_error;
    statusClass = "fail";
  }

  row(TXT[LANG].dns_hijack_test, statusClass, resultText, `${timeMs} ms`, "—", "Multiple DNS Servers", statusClass);
  if (success && statusClass === "ok") successCount++;
}

async function testQuality() {
  let totalLatency = 0, count = 0, latencies = [];

  for (const src of QUALITY_SOURCES) {
    if (!running) break;
    const t = await timed(async (signal) => {
      const res = await fetch(src.url, { signal, cache: "no-store", mode: "no-cors" });
      return true;
    }, 3000);

    const rowStatus = t.ok && t.ms < 1000 ? "ok" : t.ok ? "warn" : "fail";
    const rowResult = t.ok ? `Ping (${t.ms} ms)` : `Failed (${t.ms} ms - ${t.err || 'error'})`;
    row(`↳ ${TXT[LANG][src.nameKey]}`, rowStatus, rowResult, `${t.ms} ms`, "—", src.url);

    if (t.ok) {
      totalLatency += t.ms;
      latencies.push(t.ms);
      count++;
    }
  }

  if (count > 0) {
    const avg = Math.round(totalLatency / count);
    const jitter = latencies.length > 1 ? Math.max(...latencies) - Math.min(...latencies) : 0;
    let status = "ok", result = TXT[LANG].quality_good;
    if (avg > 200) { status = "warn"; result = TXT[LANG].quality_poor; }
    else if (avg > 100) { status = "warn"; result = TXT[LANG].quality_average; }
    row(TXT[LANG].quality_test, status, `${result}: ${TXT[LANG].ping} ${avg}ms, ${TXT[LANG].jitter} ${jitter}ms`, "—", "—", "Multiple Servers");
    if (status !== "fail") successCount++;
  } else {
    row(TXT[LANG].quality_test, "fail", TXT[LANG].quality_failed, "—", "—", "Multiple Servers");
  }
}

async function testQUIC() {
  const url = "https://quic.nginx.org/";
  
  const t = await timed(async (signal) => {
    const res = await fetch(url, { signal, cache: "no-store", mode: "cors" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return true;
  }, 3000);

  let status = "info";
  let result = TXT[LANG].quic_cors_blocked;
  
  if (t.ok) {
    status = "ok";
    result = TXT[LANG].quic_supported;
  } else if (t.err === 'Timeout' || t.err?.includes('Failed to fetch')) {
    status = "info";
    result = TXT[LANG].quic_cors_blocked;
  } else {
    status = "fail";
    result = TXT[LANG].quic_unsupported;
  }
  
  row(TXT[LANG].quic_test, status, result + (t.err ? ` (${t.err})` : ''), `${t.ms} ms`, "—", url, status);
  if (status === "ok") successCount++;
}

async function testDoH() {
  const urls = [
    "https://dns.google/resolve?name=example.com&type=A",
    "https://cloudflare-dns.com/dns-query?name=example.com&type=A"
  ];
  
  let success = false;
  let timeMs = 0;
  let errorMsg = '';

  for (const url of urls) {
    const t = await timed(async (signal) => {
      const res = await fetch(url, { 
        signal, 
        cache: "no-store",
        headers: { 'Accept': 'application/dns-json' }
      }, 5000);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      if (!data.Answer) throw new Error("Invalid DoH response");
      return true;
    }, 5000);

    timeMs = t.ms;
    if (t.ok) {
      success = true;
      break;
    } else {
      errorMsg = t.err || '';
    }
  }

  let status = success ? "ok" : (errorMsg === 'Timeout' ? "info" : "fail");
  let result = success ? TXT[LANG].doh_supported : 
               (errorMsg === 'Timeout' ? TXT[LANG].doh_timeout : TXT[LANG].doh_unsupported);
  
  row(TXT[LANG].doh_test, status, result + (errorMsg ? ` (${errorMsg})` : ''), `${timeMs} ms`, "—", "Multiple DoH Servers", status);
  if (success) successCount++;
}

async function testWebRTC() {
  const t = await timed(async () => {
    const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    pc.createDataChannel('test');
    return new Promise((resolve, reject) => {
      let done = false;
      pc.onicecandidate = e => { if (e.candidate && !done) { done = true; pc.close(); resolve(true); } };
      pc.onicegatheringstatechange = () => { if (pc.iceGatheringState === 'complete' && !done) { done = true; pc.close(); resolve(true); } };
      setTimeout(() => { if (!done) { pc.close(); reject(new Error("Timeout")); } }, 5000);
      pc.createOffer().then(o => pc.setLocalDescription(o));
    });
  });
  
  const status = t.ok ? "ok" : "fail";
  row(TXT[LANG].webrtc_test, status, t.ok ? TXT[LANG].webrtc_supported : TXT[LANG].webrtc_unsupported + (t.err ? ` (${t.err})` : ''), `${t.ms} ms`, "—", "STUN Server", status);
  if (t.ok) successCount++;
}

async function realDownload(src) {
  if (!src.isReal) totalRealTests++; // For informational, we don't count in totalRealTests
  
  const t = await timed(async (signal) => {
    const c = abortController || new AbortController();
    let read = 0;
    const res = await fetch(src.url, { signal: c.signal, cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    if (!res.body) throw new Error("No stream");
    const reader = res.body.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      read += value ? value.length : 0;
      if (read >= src.maxBytes) { c.abort(); break; }
    }
    return read;
  }, 15000);

  if (t.ok) {
    if (src.isReal) successCount++;
    const kb = (t.val / 1024).toFixed(1);
    row(TXT[LANG][src.labelKey], "ok", TXT[LANG].download_success, `${t.ms} ms`, `${kb} KB`, src.url);
  } else {
    const status = src.isReal ? "fail" : "info";
    const message = src.isReal ? TXT[LANG].download_fail : TXT[LANG].download_unavailable;
    row(TXT[LANG][src.labelKey], status, message + (t.err ? ` (${t.err})` : ''), `${t.ms} ms`, "—", src.url, status);
    
    if (src.isReal) {
      addManualLink(TXT[LANG][src.labelKey], src.url);
    }
  }
}

function showSummary() {
  summary.style.display = "block";
  let text = "";

  if (successCount >= 8) {
    text += `<p>${TXT[LANG].summary_good}</p>`;
  } else if (successCount >= 4) {
    text += `<p>${TXT[LANG].summary_medium}</p>`;
  } else {
    text += `<p>${TXT[LANG].summary_bad}</p>`;
  }

  text += `<p>${TXT[LANG].summary_ip.replace(/\[IP\]/g, ipDetected || "Unknown")}</p>`;
  
  if (ipv6Real) {
    text += `<p class="ok">✅ ${TXT[LANG].summary_ipv6_success}</p>`;
  } else {
    text += `<p class="warn">⚠️ ${TXT[LANG].summary_ipv6_note}</p>`;
  }
  
  text += `<p>${TXT[LANG].summary_success_count.replace("[COUNT]", successCount).replace("[TOTAL]", totalRealTests)}</p>`;

  if (successCount < totalRealTests) {
    text += `<p class="warn">⚠️ ${TXT[LANG].summary_cors_note}</p>`;
  }

  if (secondsElapsed > 30) {
    text += `<p class="warn">⚠️ ${TXT[LANG].summary_timeout_note}</p>`;
  }

  text += `<p>${TXT[LANG].summary_manual}</p>`;
  
  summaryContent.innerHTML = text;
}

async function run() {
  if (running) return;
  
  successCount = 0;
  totalRealTests = 0;
  ipv6Real = false;
  resetUI();
  
  running = true;
  abortController = new AbortController();
  startBtn.disabled = true;
  langSelect.disabled = true;
  startTimer();

  await ipTest("ipv4", "https://api.ipify.org", false);
  await ipTest("ipv6", "https://api64.ipify.org", true);
  await testDNSHijack();
  await testQuality();
  await testConnectivity();
  await testQUIC();
  await testDoH();
  await testWebRTC();

  for (const src of DOWNLOAD_SOURCES) {
    if (!running) break;
    await realDownload(src);
  }

  // Add manual links for known problematic sites
  addManualLink(TXT[LANG].ovh_test, "https://ovh.net/files/1Mio.dat");
  addManualLink(TXT[LANG].github_passwall, "https://github.com/Openwrt-Passwall/openwrt-passwall2/releases/download/26.2.14-1/luci-app-passwall2_26.2.14-r1_all.ipk");
  addManualLink(TXT[LANG].sourceforge_passwall, "https://sourceforge.net/projects/openwrt-passwall-build/files/releases/packages-24.10/mipsel_74kc/passwall2/Packages/download");

  showSummary();

  running = false;
  abortController = null;
  startBtn.disabled = false;
  langSelect.disabled = false;
  stopTimer();
}

startBtn.onclick = run;
</script>
</body>
</html>
