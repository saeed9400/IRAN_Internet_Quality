<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title data-lang-key="title">ابزار بررسی کیفیت اینترنت – نسخه دوم وب</title>
  <link rel="icon" href="https://raw.githubusercontent.com/saeed9400/IRAN_Net/refs/heads/main/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@33.003/Vazirmatn-font-face.css">

  <style>
    :root {
      --bg: #0a0a0f;
      --card: #181c2e;
      --text: #e0e7ff;
      --muted: #a0a8c0;
      --accent: #6366f1;
      --success: #22c55e;
      --warning: #eab308;
      --danger: #ef4444;
      --border: #2a2f4f;
      --radius: 10px;
    }
    body {
      font-family: 'Vazirmatn', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 1.5rem;
      line-height: 1.6;
    }
    header, footer {
      background: #15193a;
      padding: 1.2rem;
      text-align: center;
    }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 1.3rem;
      margin-bottom: 1.5rem;
      border: 1px solid var(--border);
    }
    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.05rem;
    }
    button:hover { background: #818cf8; }
    button.stop { background: var(--danger); }
    button.stop:hover { background: #f87171; }
    select {
      padding: 0.65rem;
      border-radius: 8px;
      background: #11151f;
      color: var(--text);
      border: 1px solid var(--border);
    }
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0 0.5rem;
      font-size: 0.92rem;
    }
    th, td {
      padding: 0.9rem 1rem;
      text-align: right;
    }
    th {
      background: #11151f;
      color: var(--muted);
      border-bottom: 2px solid var(--border);
    }
    tr {
      background: #181c2e;
      border-radius: var(--radius);
    }
    .ok { color: var(--success); font-weight: bold; }
    .fail { color: var(--danger); }
    .warn { color: var(--warning); }
    .code { font-family: monospace; direction: ltr; word-break: break-all; font-size: 0.85rem; background: #0d1117; padding: 0.3rem 0.6rem; border-radius: 6px; }
    .manual-links {
      margin: 1rem 0;
      padding: 1rem;
      background: #11151f;
      border-radius: var(--radius);
      display: none;
    }
    .manual-links a {
      display: inline-block;
      background: var(--success);
      color: white;
      padding: 0.7rem 1.4rem;
      margin: 0.4rem;
      border-radius: 8px;
      text-decoration: none;
    }
    .manual-links a:hover { background: #16a34a; }
    .summary {
      margin-top: 1.5rem;
      padding: 1.2rem;
      background: #1e2338;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      font-size: 1.05rem;
      line-height: 1.7;
      display: none;
    }
    .summary h3 {
      margin-top: 0;
      color: var(--success);
    }
    footer {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-top: 2rem;
      text-align: center;
    }
    .github-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: #60a5fa;
      text-decoration: none;
      font-size: 0.95rem;
    }
    .github-link svg { fill: currentColor; width: 20px; height: 20px; }
    .github-link:hover { color: #93c5fd; }
    a.external-link {
      color: #60a5fa;
      text-decoration: underline;
    }
    a.external-link:hover { color: #93c5fd; }
  </style>
</head>
<body>

<header>
  <h1 data-lang-key="title">ابزار بررسی کیفیت اینترنت – نسخه دوم وب</h1>
</header>

<main>
  <div class="card">
    <p data-lang-key="desc">
      در این ابزار <b>دانلود واقعی فایل</b> انجام می‌شود.<br>
      بعد از اتمام تست، نتیجه نهایی کیفیت اینترنت شما نمایش داده می‌شود.
    </p>
    <div>
      <label data-lang-key="lang_label">زبان / Language:</label>
      <select id="lang">
        <option value="fa" selected>فارسی</option>
        <option value="en">English</option>
      </select>
      <button id="start" data-lang-key="start">شروع تست</button>
    </div>
  </div>

  <div class="card">
    <table>
      <thead>
        <tr>
          <th data-lang-key="th_test">تست</th>
          <th data-lang-key="th_status">وضعیت</th>
          <th data-lang-key="th_result">نتیجه</th>
          <th data-lang-key="th_time">زمان</th>
          <th data-lang-key="th_size">حجم</th>
          <th data-lang-key="th_source">منبع / روش</th>
        </tr>
      </thead>
      <tbody id="out"></tbody>
    </table>
  </div>

  <div class="manual-links" id="manual"></div>

  <div class="summary" id="summary">
    <h3 data-lang-key="summary_title">نتیجه نهایی کیفیت اینترنت شما</h3>
    <div id="summaryContent"></div>
  </div>
</main>

<footer>
  <p data-lang-key="footer_cors">
    دانلودهایی که به دلیل CORS بلاک می‌شوند، به‌عنوان «مسدود توسط مرورگر» گزارش می‌شوند.
  </p>
  <p data-lang-key="footer_success">
    اگر دانلود واقعی انجام شد → مسیر دانلود شما باز است.
  </p>
  <a href="https://github.com/saeed9400/" target="_blank" class="github-link">
    <span data-lang-key="github">پروژه در GitHub</span>
    <svg viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
  </a>
</footer>

<script>
// ترجمه‌ها
const TXT = {
  fa: {
    title: "ابزار بررسی کیفیت اینترنت – نسخه دوم وب",
    desc: "در این ابزار <b>دانلود واقعی فایل</b> انجام می‌شود.<br>بعد از اتمام تست، نتیجه نهایی کیفیت اینترنت شما نمایش داده می‌شود.",
    lang_label: "زبان / Language:",
    start: "شروع تست",
    stop: "توقف تست",
    th_test: "تست",
    th_status: "وضعیت",
    th_result: "نتیجه",
    th_time: "زمان",
    th_size: "حجم",
    th_source: "منبع / روش",
    ok: "موفق",
    fail: "ناموفق",
    warn: "هشدار",
    download_success: "دانلود واقعی انجام شد",
    download_fail: "مسدود توسط مرورگر (CORS) – لطفاً روی لینک دستی کلیک کنید",
    no_ip: "عدم دریافت IP",
    ip_shown: "IP مشاهده‌شده: ",
    ipv4: "مسیر IPv4",
    ipv6: "مسیر IPv6",
    footer_cors: "دانلودهایی که به دلیل CORS بلاک می‌شوند، به‌عنوان «مسدود توسط مرورگر» گزارش می‌شوند.",
    footer_success: "اگر دانلود واقعی انجام شد → مسیر دانلود شما باز است.",
    manual_title: "لینک‌های دانلود دستی (در صورت بلاک fetch)",
    manual_note: "روی لینک کلیک کنید و دانلود را دستی انجام دهید تا وضعیت سرور مشخص شود.",
    summary_title: "نتیجه نهایی کیفیت اینترنت شما",
    summary_good: "کیفیت اینترنت شما <strong>خوب</strong> است.<br>مسیرهای اصلی تست‌شده باز هستند و دانلودها با سرعت قابل قبول انجام شدند.",
    summary_medium: "کیفیت اینترنت شما <strong>متوسط</strong> است.<br>بعضی مسیرها باز هستند، اما برخی به دلیل محدودیت مرورگر یا سرور بلاک شدند.",
    summary_bad: "کیفیت اینترنت شما <strong>پایین یا محدود</strong> است.<br>بیشتر مسیرها بلاک شدند – ممکن است نیاز به ابزار دور زدن داشته باشید.",
    summary_ip: "IP شما: <a href='https://whatismyipaddress.com/ip/[IP]' target='_blank' class='external-link'>[IP]</a> – این لینک را باز کنید تا مکان و نوع اتصال مشخص شود.",
    summary_success_count: "دانلودهای موفق: [COUNT] از [TOTAL]",
    summary_manual: "برای اطمینان، حتماً لینک‌های دستی را هم تست کنید. اگر دانلود دستی هم شروع نشد، مسیر واقعاً محدود است.",
    cors_note: "برخی تست‌ها به دلیل محدودیت مرورگر (CORS) ناموفق بودند. حتماً لینک‌های دستی را چک کنید.",
    github: "پروژه در GitHub",
    dns_hijack_yes: "DNS Hijack تشخیص داده شد",
    dns_hijack_no: "بدون DNS Hijack",
    dns_error: "خطا در دریافت پاسخ DNS",
    quality_good: "کیفیت خوب",
    quality_average: "کیفیت متوسط",
    quality_poor: "کیفیت ضعیف",
    quality_failed: "تست ناموفق",
    ping: "پینگ متوسط",
    jitter: "جتر",
    quic_supported: "QUIC پشتیبانی می‌شود",
    quic_unsupported: "QUIC پشتیبانی نمی‌شود",
    doh_supported: "DoH پشتیبانی می‌شود",
    doh_unsupported: "DoH پشتیبانی نمی‌شود",
    webrtc_supported: "WebRTC پشتیبانی می‌شود",
    webrtc_unsupported: "WebRTC پشتیبانی نمی‌شود",
    ipv6_yes: "IPv6 فعال است",
    ipv6_no: "IPv6 غیرفعال است",
    connectivity_good: "اتصال عمومی خوب",
    connectivity_medium: "اتصال متوسط / برخی مشکلات",
    connectivity_bad: "مشکل جدی در اتصال عمومی",
    connectivity_test: "تست اتصال عمومی / CDN / IP"
  },
  en: {
    title: "Internet Quality Tester – Web 2nd Version",
    desc: "This tool performs <b>real file download</b>.<br>After the test, a final summary of your internet quality will be shown.",
    lang_label: "Language:",
    start: "Start Test",
    stop: "Stop Test",
    th_test: "Test",
    th_status: "Status",
    th_result: "Result",
    th_time: "Time",
    th_size: "Size",
    th_source: "Source / Method",
    ok: "OK",
    fail: "Fail",
    warn: "Warning",
    download_success: "Real download completed",
    download_fail: "Blocked by browser (CORS) – please click manual link",
    no_ip: "Failed to get IP",
    ip_shown: "Visible IP: ",
    ipv4: "IPv4 Route",
    ipv6: "IPv6 Route",
    footer_cors: "Downloads blocked by CORS are reported as «Blocked by browser».",
    footer_success: "If real download succeeded → your download path is open.",
    manual_title: "Manual Download Links (if fetch blocked)",
    manual_note: "Click the link and download manually to check server accessibility.",
    summary_title: "Final Internet Quality Summary",
    summary_good: "Your internet quality is <strong>good</strong>.<br>Main tested paths are open and download speeds are acceptable.",
    summary_medium: "Your internet quality is <strong>medium</strong>.<br>Some paths work, but others are blocked by browser/server restrictions.",
    summary_bad: "Your internet quality is <strong>low or restricted</strong>.<br>Most paths are blocked – you may need better circumvention tools.",
    summary_ip: "Your IP: <a href='https://whatismyipaddress.com/ip/[IP]' target='_blank' class='external-link'>[IP]</a> – Open this link to check location and connection type.",
    summary_success_count: "Successful downloads: [COUNT] of [TOTAL]",
    summary_manual: "For certainty, test the manual links. If manual download also fails, the path is truly restricted.",
    cors_note: "Some tests failed due to browser restrictions (CORS). Please check the manual links.",
    github: "Project on GitHub",
    dns_hijack_yes: "DNS Hijack detected",
    dns_hijack_no: "No DNS Hijack",
    dns_error: "Error getting DNS response",
    quality_good: "Good quality",
    quality_average: "Average quality",
    quality_poor: "Poor quality",
    quality_failed: "Test failed",
    ping: "Average ping",
    jitter: "Jitter",
    quic_supported: "QUIC supported",
    quic_unsupported: "QUIC unsupported",
    doh_supported: "DoH supported",
    doh_unsupported: "DoH unsupported",
    webrtc_supported: "WebRTC supported",
    webrtc_unsupported: "WebRTC unsupported",
    ipv6_yes: "IPv6 enabled",
    ipv6_no: "IPv6 disabled",
    connectivity_good: "Good general connectivity",
    connectivity_medium: "Medium connectivity / some issues",
    connectivity_bad: "Serious connectivity issues",
    connectivity_test: "General / CDN / IP Connectivity Test"
  }
};

let LANG = "fa";
let running = false;
let successCount = 0;
let totalTests = 12;
let ipDetected = "";
let abortController = null;

const langSelect = document.getElementById("lang");
const startBtn = document.getElementById("start");
const out = document.getElementById("out");
const manual = document.getElementById("manual");
const summary = document.getElementById("summary");
const summaryContent = document.getElementById("summaryContent");

// منابع تست کیفیت (پینگ)
const QUALITY_SOURCES = [
  { name: "Google", url: "https://www.google.com/generate_204" },
  { name: "Cloudflare", url: "https://www.cloudflare.com/cdn-cgi/trace" },
  { name: "Wikipedia", url: "https://en.wikipedia.org/api/rest_v1/page/random/title" },
  { name: "GitHub", url: "https://api.github.com" },
  { name: "OpenWRT", url: "https://downloads.openwrt.org/releases/lastupdate" }
];

// منابع تست اتصال عمومی
const CONNECTIVITY_SOURCES = [
  { name: "Cloudflare Trace", url: "https://www.cloudflare.com/cdn-cgi/trace", check: text => text.includes("colo=") || text.includes("fl=") },
  { name: "ipify IPv4", url: "https://api.ipify.org", check: text => text.trim().match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) },
  { name: "httpbin Get", url: "https://httpbin.org/get", check: json => json && json.origin },
  { name: "Cloudflare Speed 100KB", url: "https://speed.cloudflare.com/__down?bytes=100000", check: () => true }
];

// منابع دانلود
const DOWNLOAD_SOURCES = [
  { label: "GitHub Raw", url: "https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore", maxBytes: 512*1024 },
  { label: "jsDelivr lodash", url: "https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js", maxBytes: 512*1024 },
  { label: "unpkg react", url: "https://unpkg.com/react@18/umd/react.production.min.js", maxBytes: 512*1024 },
  { label: "OpenWRT lastupdate", url: "https://downloads.openwrt.org/releases/lastupdate", maxBytes: 128*1024 },
  { label: "Passwall2 IPK", url: "https://github.com/Openwrt-Passwall/openwrt-passwall2/releases/download/26.2.14-1/luci-app-passwall2_26.2.14-r1_all.ipk", maxBytes: 512*1024 },
  { label: "Passwall Packages SF", url: "https://sourceforge.net/projects/openwrt-passwall-build/files/releases/packages-24.10/mipsel_74kc/passwall2/Packages/download", maxBytes: 512*1024 },
  { label: "Cloudflare Speedtest", url: "https://speed.cloudflare.com/__down?bytes=1000000", maxBytes: 1024*1024 },
  { label: "OVH Test File", url: "https://ovh.net/files/1Mio.dat", maxBytes: 1024*1024 }
];

function updateLanguage() {
  document.documentElement.lang = LANG;
  document.documentElement.dir = LANG === "fa" ? "rtl" : "ltr";
  document.querySelectorAll("[data-lang-key]").forEach(el => {
    const k = el.getAttribute("data-lang-key");
    if (TXT[LANG][k]) el.innerHTML = TXT[LANG][k];
  });
  startBtn.textContent = running ? TXT[LANG].stop : TXT[LANG].start;
}

langSelect.onchange = e => {
  LANG = e.target.value;
  updateLanguage();
  out.innerHTML = "";
  manual.innerHTML = `<h3>${TXT[LANG].manual_title}</h3>`;
  manual.style.display = "none";
  summary.style.display = "none";
  summaryContent.innerHTML = "";
};

updateLanguage();

function row(test, status, result, time = "—", size = "—", source = "") {
  const tr = document.createElement("tr");
  tr.innerHTML = `<td>${test}</td><td class="${status}">${TXT[LANG][status] || status}</td><td>${result}</td><td>${time}</td><td>${size}</td><td class="code">${source}</td>`;
  out.appendChild(tr);
}

async function timed(fn) {
  const start = performance.now();
  try {
    const val = await fn();
    return { ok: true, val, ms: Math.round(performance.now() - start) };
  } catch (err) {
    return { ok: false, err: err.message, ms: Math.round(performance.now() - start) };
  }
}

async function realDownload(label, url, maxBytes) {
  let effectiveUrl = url;
  let isProxied = false;
  const proxy = "https://api.allorigins.win/raw?url=";

  const t = await timed(async () => {
    const c = abortController || new AbortController();
    let read = 0;
    const res = await fetch(effectiveUrl, { signal: c.signal, cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    if (!res.body) throw new Error("No stream");
    const reader = res.body.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      read += value ? value.length : 0;
      if (read >= maxBytes) { c.abort(); break; }
    }
    return read;
  });

  if (t.ok) {
    successCount++;
    const kb = (t.val / 1024).toFixed(1);
    row(label, "ok", TXT[LANG].download_success + (isProxied ? " (via proxy)" : ""), `${t.ms} ms`, `${kb} KB`, effectiveUrl);
  } else if (t.err.includes("CORS") || t.err.includes("Access-Control-Allow-Origin")) {
    // Try with proxy
    effectiveUrl = proxy + encodeURIComponent(url);
    isProxied = true;
    const tProxy = await timed(async () => {
      const c = abortController || new AbortController();
      let read = 0;
      const res = await fetch(effectiveUrl, { signal: c.signal, cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      if (!res.body) throw new Error("No stream");
      const reader = res.body.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        read += value ? value.length : 0;
        if (read >= maxBytes) { c.abort(); break; }
      }
      return read;
    });

    if (tProxy.ok) {
      successCount++;
      const kb = (tProxy.val / 1024).toFixed(1);
      row(label, "ok", TXT[LANG].download_success + " (via proxy)", `${tProxy.ms} ms`, `${kb} KB`, effectiveUrl);
    } else {
      row(label, "fail", TXT[LANG].download_fail + ` (${tProxy.err || 'خطا'})`, `${tProxy.ms} ms`, "—", url);
      addManualLink(label, url);
    }
  } else {
    row(label, "fail", TXT[LANG].download_fail + ` (${t.err || 'خطا'})`, `${t.ms} ms`, "—", url);
    addManualLink(label, url);
  }
}

function addManualLink(label, url) {
  const div = document.createElement("div");
  div.innerHTML = `<p>${TXT[LANG].manual_note}</p>`;
  const a = document.createElement("a");
  a.href = url;
  a.target = "_blank";
  a.rel = "noopener noreferrer";
  a.textContent = label;
  div.appendChild(a);
  manual.appendChild(div);
  manual.style.display = "block";
}

async function ipTest(label, url, expectV6) {
  const t = await timed(async () => {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return (await res.text()).trim();
  });

  if (t.ok) {
    const ip = t.val;
    const isV6 = ip.includes(":");
    const st = (isV6 === expectV6) ? "ok" : "warn";
    row(label, st, TXT[LANG].ip_shown + ip, `${t.ms} ms`, "—", url);
    if (label.includes("IPv4")) ipDetected = ip;
  } else {
    row(label, "fail", TXT[LANG].no_ip + ` (${t.err || 'خطا'})`, `${t.ms} ms`, "—", url);
  }
}

async function testConnectivity() {
  const label = TXT[LANG].connectivity_test;
  let success = 0;
  let totalTime = 0;
  let details = [];

  for (const src of CONNECTIVITY_SOURCES) {
    if (!running) break;
    const t = await timed(async () => {
      const res = await fetch(src.url, { cache: "no-store", mode: "cors" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const content = await (res.headers.get("content-type")?.includes("json") ? res.json() : res.text());
      if (src.check && !src.check(content)) throw new Error("Invalid content");
      return true;
    });

    const rowStatus = t.ok ? "ok" : "fail";
    const rowResult = t.ok ? `موفق (${t.ms} ms)` : `ناموفق (${t.ms} ms - ${t.err || 'خطا'})`;
    row(`↳ ${src.name}`, rowStatus, rowResult, `${t.ms} ms`, "—", src.url);

    if (t.ok) {
      success++;
      totalTime += t.ms;
    }
    details.push(`${src.name}: ${t.ok ? "OK" : "Fail"}`);
  }

  const finalStatus = success >= CONNECTIVITY_SOURCES.length ? "ok" : success >= CONNECTIVITY_SOURCES.length / 2 ? "warn" : "fail";
  const avg = success > 0 ? Math.round(totalTime / success) : "—";

  row(label, finalStatus, 
    finalStatus === "ok" ? TXT[LANG].connectivity_good :
    finalStatus === "warn" ? TXT[LANG].connectivity_medium :
    TXT[LANG].connectivity_bad,
    "—", "—", `موفق: ${success}/${CONNECTIVITY_SOURCES.length} • میانگین: ${avg} ms`);

  if (success >= CONNECTIVITY_SOURCES.length / 2) successCount++;
}

async function testDNSHijack() {
  const label = "تست DNS Hijack";
  const url = "https://dns.google/resolve?name=telegram.org&type=A";

  const t = await timed(async () => {
    const res = await fetch(url, { cache: "no-store", mode: "cors" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  });

  let hijacked = false;
  let resultText = TXT[LANG].dns_hijack_no;
  let statusClass = "ok";

  if (t.ok && t.val.Answer) {
    for (const ans of t.val.Answer) {
      const ip = ans.data;
      if (ip && (ip.startsWith("10.") || ip.startsWith("192.168.") || ip.startsWith("172.") || ip.startsWith("37.228."))) {
        hijacked = true;
        resultText = TXT[LANG].dns_hijack_yes + ` (${ip})`;
        statusClass = "warn";
        break;
      }
    }
  } else {
    resultText = TXT[LANG].dns_error + ` (${t.err || 'خطا'})`;
    statusClass = "fail";
  }

  row(label, statusClass, resultText, `${t.ms} ms`, "—", url);

  if (!hijacked && t.ok) successCount++;
}

async function testIPv6() {
  const label = TXT[LANG].ipv6;
  const url = "https://api64.ipify.org";
  const t = await timed(async () => {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.text();
  });
  if (t.ok && t.val.includes(":")) {
    row(label, "ok", TXT[LANG].ipv6_yes + ": " + t.val.substring(0, 20) + "...", `${t.ms} ms`, "—", url);
    successCount++;
  } else {
    row(label, "fail", TXT[LANG].ipv6_no + ` (${t.err || ''})`, `${t.ms} ms`, "—", url);
  }
}

async function testQuality() {
  const label = "تست کیفیت (پینگ)";
  let totalLatency = 0, count = 0, latencies = [];

  for (const src of QUALITY_SOURCES) {
    if (!running) break;
    const t = await timed(async () => {
      const res = await fetch(src.url, { cache: "no-store", mode: "no-cors" });
      return true; // فقط زمان مهم است، status همیشه 0 است
    });

    const rowStatus = t.ms < 1000 ? "ok" : "warn"; // بر اساس زمان
    const rowResult = `پینگ (${t.ms} ms)`;
    row(`↳ ${src.name}`, rowStatus, rowResult, `${t.ms} ms`, "—", src.url);

    totalLatency += t.ms;
    latencies.push(t.ms);
    count++;
  }

  if (count > 0) {
    const avg = Math.round(totalLatency / count);
    const jitter = latencies.length > 1 ? Math.max(...latencies) - Math.min(...latencies) : 0;
    let status = "ok", result = TXT[LANG].quality_good;
    if (avg > 200) { status = "warn"; result = TXT[LANG].quality_poor; }
    else if (avg > 100) { status = "warn"; result = TXT[LANG].quality_average; }
    row(label, status, result + `: ${TXT[LANG].ping} ${avg}ms, ${TXT[LANG].jitter} ${jitter}ms`, "—", "—", "Multiple Servers");
    if (status !== "fail") successCount++;
  } else {
    row(label, "fail", TXT[LANG].quality_failed, "—", "—", "Multiple Servers");
  }
}

async function testQUIC() {
  const label = "تست QUIC";
  const url = "https://quic.nginx.org/";

  const t = await timed(async () => {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const entry = performance.getEntriesByName(url)[0];
    if (!entry) throw new Error("No performance entry");
    const protocol = entry.nextHopProtocol || '';
    if (protocol === 'h3' || protocol.includes('quic')) {
      return protocol;
    }
    throw new Error("Not using QUIC: " + protocol);
  });

  const status = t.ok ? "ok" : "fail";
  row(label, status, t.ok ? TXT[LANG].quic_supported + ` (${t.val})` : TXT[LANG].quic_unsupported + ` (${t.err || 'خطا'})`, `${t.ms} ms`, "—", url);
  if (t.ok) successCount++;
}

async function testDoH() {
  const label = "تست DoH";
  const url = "https://dns.google/resolve?name=example.com&type=A";
  const t = await timed(async () => {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if (!data.Answer) throw new Error("Invalid DoH response");
    return true;
  });
  const status = t.ok ? "ok" : "fail";
  row(label, status, t.ok ? TXT[LANG].doh_supported : TXT[LANG].doh_unsupported + ` (${t.err || 'خطا'})`, `${t.ms} ms`, "—", url);
  if (t.ok) successCount++;
}

async function testWebRTC() {
  const label = "تست WebRTC";
  const t = await timed(async () => {
    const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    pc.createDataChannel('test');
    return new Promise((resolve, reject) => {
      let done = false;
      pc.onicecandidate = e => { if (e.candidate && !done) { done = true; pc.close(); resolve(true); } };
      pc.onicegatheringstatechange = () => { if (pc.iceGatheringState === 'complete' && !done) { done = true; pc.close(); resolve(true); } };
      setTimeout(() => { if (!done) { pc.close(); reject(new Error("Timeout")); } }, 5000);
      pc.createOffer().then(o => pc.setLocalDescription(o));
    });
  });
  const status = t.ok ? "ok" : "fail";
  row(label, status, t.ok ? TXT[LANG].webrtc_supported : TXT[LANG].webrtc_unsupported + ` (${t.err || 'خطا'})`, `${t.ms} ms`, "—", "STUN Server");
  if (t.ok) successCount++;
}

function showSummary() {
  summary.style.display = "block";
  let text = "";

  if (successCount >= 10) {
    text += `<p>${TXT[LANG].summary_good}</p>`;
  } else if (successCount >= 5) {
    text += `<p>${TXT[LANG].summary_medium}</p>`;
  } else {
    text += `<p>${TXT[LANG].summary_bad}</p>`;
  }

  text += `<p>${TXT[LANG].summary_ip.replace(/\[IP\]/g, ipDetected || "نامشخص")}</p>`;
  text += `<p>${TXT[LANG].summary_success_count.replace("[COUNT]", successCount).replace("[TOTAL]", totalTests)}</p>`;

  if (successCount < totalTests) {
    text += `<p>${TXT[LANG].cors_note}</p>`;
  }

  text += `<p>${TXT[LANG].summary_manual}</p>`;

  summaryContent.innerHTML = text;
}

async function run() {
  successCount = 0;
  out.innerHTML = "";
  manual.innerHTML = `<h3>${TXT[LANG].manual_title}</h3>`;
  manual.style.display = "none";
  summary.style.display = "none";
  running = true;
  abortController = new AbortController();
  startBtn.textContent = TXT[LANG].stop;
  startBtn.classList.add("stop");
  langSelect.disabled = true;

  await ipTest(TXT[LANG].ipv4, "https://api.ipify.org", false);
  await testIPv6();
  await testDNSHijack();
  await testQuality();
  await testConnectivity();
  await testQUIC();
  await testDoH();
  await testWebRTC();

  for (const src of DOWNLOAD_SOURCES) {
    if (!running) break;
    await realDownload(src.label, src.url, src.maxBytes);
  }

  showSummary();

  running = false;
  abortController = null;
  langSelect.disabled = false;
  startBtn.textContent = TXT[LANG].start;
  startBtn.classList.remove("stop");
}

startBtn.onclick = () => {
  if (running) {
    running = false;
    if (abortController) abortController.abort();
  } else {
    run();
  }
};
</script>
</body>
</html>